<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Milan Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
                            <header id="header">
                                <a href="index.html" class="logo"><strong>Milan Garg</strong></a>
                                <ul class="icons">
                                    <li>  <a href="https://www.linkedin.com/in/milan-garg-540421294/" target="_blank" class="icon brands fa-linkedin"><span class="label">Linkedin</span></a></li>
                                </ul>
                            </header>

							<!-- Content -->
								<section>
									<header class="main">
										<h1>Building a Scalable Retail Data Extraction Pipeline</h1>
									</header>

									<span class="image main"><img src="images/retail-pipeline/uk_supermarkets.jpg" alt="" /></span>
                                    <p>In the ever-evolving retail industry, having access to real-time data is crucial for making informed decisions. This project aims to build a scalable data extraction pipeline that scrapes retail data from multiple stores, processes and cleans it, and ultimately stores it for analysis. By tracking changing grocery prices over time, this project helps in monitoring inflation trends, understanding market dynamics, and making data-driven decisions. Accurate and up-to-date retail data can provide valuable insights for both consumers and businesses, helping to identify pricing trends, competitive positioning, and economic shifts.</p>
									<p>To achieve this, we leverage a combination of powerful technologies. Selenium is used for web scraping, Python and Pandas for data processing and cleaning, and Apache Airflow for pipeline orchestration. Containerization with Docker ensures portability, while deployment on AWS services such as Amazon S3, ECR, and EC2 guarantees scalability and reliability. This blog post will walk you through each step of the project, from data scraping to deployment, and address challenges such as IP blocking by retailers.</p>
                                    

									<hr class="major" />

									<h2>Prerequisites</h2>
                                    <ul>
                                        <li><strong>Basic Knowledge of Python:</strong> Understanding of Python programming, including libraries such as Pandas and Selenium.</li>
                                        <li><strong>Familiarity with Web Scraping:</strong> Basic knowledge of web scraping techniques and tools.</li>
                                        <li><strong>Understanding of Docker:</strong> Basic knowledge of Docker for containerization.</li>
                                        <li><strong>Experience with Cloud Services:</strong>
                                            <ul>
                                                <li>Amazon S3 for storage.</li>
                                                <li>Amazon ECR for Docker image registry.</li>
                                                <li>DigitalOcean for deployment.</li>
                                            </ul>
                                        </li>
                                        <li><strong>Apache Airflow Knowledge:</strong> Understanding of Apache Airflow for orchestrating data pipelines.</li>
                                        <li><strong>Development Environment:</strong>
                                            <ul>
                                                <li>Python installed on your machine.</li>
                                                <li>Docker installed and running.</li>
                                                <li>AWS CLI configured with your AWS account.</li>
                                                <li>An IDE or text editor for coding (e.g., VS Code, PyCharm).</li>
                                            </ul>
                                        </li>
                                        <li><strong>Accounts and Subscriptions:</strong>
                                            <ul>
                                                <li>AWS account with appropriate permissions for S3 and ECR.</li>
                                                <li>DigitalOcean account for deployment.</li>
                                                <li>Any necessary proxy or VPN services for overcoming IP blocking issues.</li>
                                            </ul>
                                        </li>
                                    </ul>

                                    <h2>Project Structure</h2>

                                    <p>The full pipeline we will be building is shown below.</p>
                                    <span><img width="80%" src="images/retail-pipeline/retail_pipeline_airflow.jpg" alt="" /></span>

                                    <p>The full codebase for the process can be checked from Github, a template config file is also provided in which security credentials need to be updated to run the code. The program runs using docker and should work by using docker-compose commands.</p>
                                    <p>The github link for the project is <a title="a" href="https://github.com/luminous198/RetailDataEngineeringUK/tree/milan" target="_blank"><span class="label">here.</span></a></p>

                                    <p>A well-structured project is crucial for several reasons:</p>
                                    <ul>
                                        <li><strong>Readability and Maintainability:</strong> A clear and logical structure makes it easier for developers to understand and navigate the codebase. This is especially important for onboarding new team members and for long-term maintenance.</li>
                                        <li><strong>Scalability:</strong> As the project grows, a well-organized structure allows for easy addition of new features and modules without causing clutter or confusion.</li>
                                        <li><strong>Collaboration:</strong> A consistent structure helps multiple developers work together efficiently, as they can easily find and understand different parts of the project.</li>
                                        <li><strong>Debugging and Testing:</strong> A modular structure allows for easier testing and debugging. It’s simpler to isolate and fix issues when the code is organized logically.</li>
                                    </ul>

                                    <p>Next, we look at how the project directory is setup according to best practices.</p>

                                    <div class="row">
                                        <div class="col-8">
                                            <ul>
                                                <li><strong>commons/:</strong>Contains config related files.</li>
                                                <li><strong>dags/:</strong> Houses the Directed Acyclic Graphs (DAGs) for Apache Airflow, defining pipelines, including tasks and their dependencies.</li>
                                                <li><strong>data-loading/:</strong> Responsible for scripts and modules related to loading data into the database, we currently do not load to any database, instead just save the files to Amazon S3.</li>
                                                <li><strong>data_collector/:</strong> Dedicated to the data scraping logic, where data is collected from different retail websites.</li>
                                                <li><strong>data_utils/:</strong> Contains utility functions and helper scripts for processing and manipulating data.</li>
                                                <li><strong>docs/:</strong> Meant for documentation, including guides, API documentation, and other resources to help developers understand and use the project.</li>
                                                <li><strong>retail-metadata/:</strong> Stores metadata information about the retailers, such as mappings, brand data and other reference data.</li>
                                                <li><strong>s3_utils/:</strong> Contains scripts and modules for interacting with Amazon S3, such as uploading and downloading files.</li>
                                                <li><strong>static_vars/:</strong> Holds static variables and configuration settings that are used throughout the project. For instance, names of stores used.</li>
                                                <li><strong>temp/:</strong> Used for temporary files and data during the execution of the project, excluded from version control.</li>
                                                <li><strong>transforms/:</strong> Contains scripts and modules for transforming and cleaning data as part of the ETL (Extract, Transform, Load) process.</li>
                                                <li><strong>.gitignore:</strong> Specifies which files and directories should be ignored by Git, helping to keep the repository clean from unnecessary files.</li>
                                                <li><strong>airflow.env:</strong> Contains configuration settings for running Apache Airflow.</li>
                                                <li><strong>docker-compose.yml:</strong> Defines services, networks, and volumes for Docker Compose, enabling multi-container Docker applications.</li>
                                                <li><strong>Dockerfile:</strong> Contains instructions for building a Docker image for the project.</li>
                                                <li><strong>Dockerfile.chrome, Dockerfile.firefox:</strong> Specific Dockerfiles for creating images with Chrome and Firefox browsers, for Selenium web scraping.</li>
                                                <li><strong>Dockerfile.postgres, Dockerfile.redis:</strong> Dockerfiles for creating images for PostgreSQL and Redis, used by airflow.</li>
                                                <li><strong>README.md:</strong> Provides an overview of the project, including instructions on how to set up and use it.</li>
                                                <li><strong>requirements.txt:</strong> Lists the Python dependencies needed for the project.</li>
                                                <li><strong>server-docker-compose.yml:</strong> An additional Docker Compose file, for setting up server-side services.</li>
                                                <li><strong>__init__.py:</strong> Indicates that the directory should be treated as a Python package.</li>
                                            </ul>
                                        </div>
                                        <div class="col-4">
                                            <span><img src="images/retail-pipeline/project_strucure.jpg" alt="" /></span>
                                        </div>
                                    </div>

									<hr class="major" />
									<h2>Data Scraping with Selenium</h2>

                                    <p>Data scraping is the major component of our pipeline, focusing on extracting retail data from selected stores: Morrisons, Aldi, and Asda.</p>

                                    <h3>Store Selection and Website Layouts</h3>
                                    <p>We chose Morrisons, Aldi, and Asda for their comprehensive product offerings and varying website layouts, which present unique challenges and opportunities for data scraping.</p>
                                
                                    <ul>
                                        <li><strong>Morrisons:</strong>
                                            <ul>
                                                <li>Products are loaded dynamically as you scroll.</li>
                                                <li>We select a category, scroll to the bottom of the page using Selenium, and scrape all product boxes.</li>
                                            </ul>
                                        </li>
                                        <li><strong>Aldi and Asda:</strong>
                                            <ul>
                                                <li>These stores follow a similar layout with a paginated approach per category.</li>
                                                <li>Each category has multiple pages, and we iterate through each page, downloading the content within the product boxes.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                
                                    <h3>Scraping Process</h3>
                                    <ol>
                                        <li><strong>Define Categories:</strong>
                                            <p>We begin by defining a list of categories to scrape for each store.</p>
                                        </li>
                                        <li><strong>Scraping Aldi and Asda:</strong>
                                            <p>For each category, we navigate through multiple pages. On each page, we extract the content within the product boxes.</p>
                                        </li>
                                        <li><strong>Scraping Morrisons:</strong>
                                            <p>We select a category and use Selenium to scroll to the bottom of the page. Once all products are loaded, we scrape the content within the product boxes.</p>
                                        </li>
                                    </ol>
                                
                                    <h3>Data Handling</h3>
                                    <p>After collecting the data from both scrapers, we consolidate the information into a Pandas DataFrame. This data is then written to separate CSV files for further processing and analysis.</p>
                                
                                    <h3>Code Structure</h3>
                                    <p>All scraper codes are designed to be independent of each other, following Object-Oriented Programming (OOP) principles. This approach allows us to reuse common functions, such as setting up the browser for Selenium, ensuring modularity and ease of maintenance.</p>
                                

                                    <hr class="major" />
									<h2>Saving Data to Files</h2>
                                    
                                    <p>Defining a file structure is crucial when implementing a scraper. Care must be taken to not fill up too much memory when scraping data, a natural checkpoint must be identified to save data on incremental basis. We choose this checkpoint as a product category for each store. Additionally, it is better to make the scraper recovery proof meaning, the entire dataset does not get lost in case the scraper crashes. We follow the below best practices in order to overcome these challenges.</p>

                                    <ul>
                                        <li>Each category's data is saved to a different file to avoid taking up too much RAM and to ensure data is not lost if the scraper crashes.</li>
                                        <li>When starting the scraper, the output folder is checked for category data that has already been scraped. If data for a category is found, that category is skipped. This mechanism is in place to save duplicate work and ensure efficiency if the scraper crashes and needs to be restarted.</li>
                                        <li>The output format for each category can vary, but a CSV file is always written.</li>
                                        <li>The category names can differ for each store, accommodating the unique categorizations used by Morrisons, Aldi, and Asda.</li>
                                    </ul>

                                    <p>The output structure of the scraping directory is shown in the below image.</p>
                                    <span><img src="images/retail-pipeline/scraping_dir.jpg" alt="" /></span>

                                    <hr class="major" />
									<h2>Data Integration with Pandas</h2>
                                    <p>This transformation is designed to take the retail data we have scraped from three different stores—Morrisons, Aldi, and Asda—and merge it into one comprehensive file. This combined data file makes it easier to analyze and compare prices and other product details across different stores.</p>

                                    <h3>Purpose</h3>
                                    <p>The main purpose of this script is to:</p>
                                    <ul>
                                        <li>Consolidate data from multiple sources into a single, uniform format.</li>
                                        <li>Facilitate easier data analysis by having all the information in one place.</li>
                                        <li>Ensure that the data from different stores can be compared directly.</li>
                                    </ul>
                                
                                    <h3>Challenges in Integration</h3>
                                    <ul>
                                        <li><strong>Different Data Formats:</strong>
                                            <p>Each store may present its data differently. For example, Morrisons might use different column names or units of measurement compared to Aldi and Asda.</p>
                                            <p><strong>Solution:</strong> The script renames and standardizes columns so that the data from all three stores has the same structure.</p>
                                        </li>
                                        <li><strong>Data Integrity and Consistency:</strong>
                                            <p>Ensuring that the data remains accurate and consistent when combining it from different sources.</p>
                                            <p><strong>Solution:</strong> The script adds common columns like <code>scrape_date</code> and <code>Storename</code> to keep track of where and when the data was collected. It also handles missing values and differences in column names.</p>
                                        </li>
                                        <li><strong>Handling Missing Data:</strong>
                                            <p>Some stores might not have certain data fields, such as ratings or promotions.</p>
                                            <p><strong>Solution:</strong> The script fills in missing data with empty values where necessary, ensuring that the final dataset remains consistent.</p>
                                        </li>
                                        <li><strong>Efficiency and Performance:</strong>
                                            <p>Combining large datasets can be resource-intensive.</p>
                                            <p><strong>Solution:</strong> The script processes each store's data separately and then merges them, which helps manage memory usage and keeps the process efficient.</p>
                                        </li>
                                    </ul>
                                
                                    <h3>How the Script Works</h3>
                                    <ol>
                                        <li><strong>Reading Data:</strong>
                                            <p>The script reads the data files from each store's directory for a given date. It adds additional columns like <code>scrape_date</code> and <code>Storename</code> to each dataset.</p>
                                        </li>
                                        <li><strong>Standardizing Data:</strong>
                                            <p>The script standardizes the column names across all datasets. For example, it ensures that the price per unit of measure is consistently named.</p>
                                        </li>
                                        <li><strong>Combining Data:</strong>
                                            <p>The script merges the standardized data from all three stores into one DataFrame. It then saves this combined data into a CSV file, which can be easily used for further analysis.</p>
                                        </li>
                                    </ol>

                                    <hr class="major" />
									<h2>Data Cleanup</h2>

                                    <p>This transformation is designed to clean and standardize the combined data file created from the retail data of Morrisons, Aldi, and Asda. The goal is to ensure that the data is accurate, consistent, and ready for analysis. The cleanup process involves various steps to normalize pricing, standardize units of measurement, identify product brands, and create unique identifiers for each product.</p>

                                    <h3>Purpose</h3>
                                    <p>The main purpose of this script is to:</p>
                                    <ul>
                                        <li>Clean and standardize the combined data from multiple sources.</li>
                                        <li>Ensure consistency in the data for easier analysis.</li>
                                        <li>Add additional useful information, such as product brands and unique identifiers.</li>
                                    </ul>
                                
                                    <h3>Cleanups Applied</h3>
                                    <ul>
                                        <li><strong>Inconsistent Price Formats:</strong>
                                            <p>Prices may be represented differently across the datasets.</p>
                                            <p><strong>Solution:</strong> The <code>cleanup_price</code> function standardizes price formats by removing currency symbols and converting values to a uniform float format.</p>
                                        </li>
                                        <li><strong>Different Volume Units:</strong>
                                            <p>Volumes may be listed in various units (e.g., kg, g, ml).</p>
                                            <p><strong>Solution:</strong> The <code>standardize_volume_tuple</code> function converts different volume strings to standardized units (e.g., kg, l) and returns them as a tuple.</p>
                                        </li>
                                        <li><strong>Cleaning Product Names:</strong>
                                            <p>Product names may contain volume information or other inconsistencies.</p>
                                            <p><strong>Solution:</strong> The <code>clean_product_name</code> function removes volume information from product names to standardize them.</p>
                                        </li>
                                        <li><strong>Brand Identification:</strong>
                                            <p>Identifying the brand of a product can be challenging due to variations in product names.</p>
                                            <p><strong>Solution:</strong> The <code>add_brand</code> function checks product names against a list of known brands and marks products accordingly.</p>
                                        </li>
                                        <li><strong>Creating Unique Identifiers:</strong>
                                            <p>Each product needs a unique identifier for tracking and analysis.</p>
                                            <p><strong>Solution:</strong> The <code>create_fingerprint</code> function generates a unique fingerprint for each product based on its name, store, and volume.</p>
                                        </li>
                                    </ul>
                                
                                    <h3>How the Script Works</h3>
                                    <ol>
                                        <li><strong>Reading and Cleaning Data:</strong>
                                            <p>The script reads the combined data file created from Morrisons, Aldi, and Asda. It cleans the data by standardizing prices and volumes, and by cleaning product names.</p>
                                        </li>
                                        <li><strong>Identifying Brands:</strong>
                                            <p>The script uses a pre-defined list of brands to identify and mark brands in the product names.</p>
                                        </li>
                                        <li><strong>Creating Unique Identifiers:</strong>
                                            <p>It generates unique fingerprints for each product to ensure that each entry can be uniquely identified.</p>
                                        </li>
                                        <li><strong>Saving Cleaned Data:</strong>
                                            <p>The cleaned and standardized data is saved to a new CSV file, making it ready for analysis.</p>
                                        </li>
                                    </ol>

                                    <hr class="major" />
									<h2>Saving Data to Amazon S3</h2>

                                    <p>The last step in the pipeline is to upload the cleaned file to Amazon S3, a cloud storage service. The main functions of the script include connecting to S3, creating a bucket if it doesn't already exist, and uploading files to the specified bucket.</p>

                                    <h3>Key Functions</h3>
                                    <ul>
                                        <li><strong>Connecting to S3:</strong>
                                            <p>The <code>connect_to_s3</code> function sets up a connection to Amazon S3 using the provided access credentials. This connection allows the script to interact with S3, such as uploading or checking for files.</p>
                                        </li>
                                        <li><strong>Creating a Bucket:</strong>
                                            <p>The <code>create_bucket_if_not_exist</code> function checks if a specified bucket (a storage container in S3) exists. If the bucket does not exist, it creates one. If it already exists, it simply confirms its existence.</p>
                                        </li>
                                        <li><strong>Uploading Files:</strong>
                                            <p>The <code>upload_to_s3</code> function uploads a file to the specified bucket in S3. It places the file in a 'raw' folder within the bucket and provides feedback on whether the upload was successful or if the file was not found.</p>
                                        </li>
                                        <li><strong>Uploading Cleaned Files:</strong>
                                            <p>The <code>upload_clean_file_to_s3</code> function is designed to be used in a workflow (e.g., with Apache Airflow). It retrieves the path of a cleaned data file, connects to S3, ensures the bucket exists, and uploads the file to S3.</p>
                                        </li>
                                    </ul>

                                    <hr class="major" />
									<h2>Pipeline Orchestration with Apache Airflow</h2>

                                    <p>The Airflow pipeline is designed to automate the process of extracting, transforming, and loading (ETL) retail data from multiple stores (Morrisons, Aldi, and Asda) into Amazon S3. The pipeline runs daily and follows these main steps:</p>

                                    <h3>Common Settings</h3>
                                    <p>Each extraction task (<code>aldi_extract</code>, <code>asda_extract</code>, <code>morrissons_extract</code>) will retry up to 5 times with a 30-second delay between attempts in case of failure.</p>
                                
                                    <h3>Steps in the Pipeline</h3>
                                    <ul>
                                        <li><strong>Extraction from Aldi:</strong>
                                            <p>The <code>aldi_extract</code> task uses the <code>scrape_aldi</code> function to scrape data from the Aldi website.</p>
                                        </li>
                                        <li><strong>Extraction from Asda:</strong>
                                            <p>The <code>asda_extract</code> task uses the <code>scrape_asda</code> function to scrape data from the Asda website.</p>
                                        </li>
                                        <li><strong>Extraction from Morrisons:</strong>
                                            <p>The <code>morrissons_extract</code> task uses the <code>scrape_morrissons</code> function to scrape data from the Morrisons website.</p>
                                        </li>
                                        <li><strong>Data File Creation:</strong>
                                            <p>The <code>datafile_creation</code> task uses the <code>create_datafile</code> function to combine the extracted data from all three stores into a unified data file. It ensures that data from different sources is merged into a single file for further processing.</p>
                                        </li>
                                        <li><strong>Data Cleanup:</strong>
                                            <p>The <code>datafile_cleanup</code> task uses the <code>data_cleanup</code> function to clean and standardize the unified data file. This step ensures that the data is consistent, accurate, and ready for analysis by performing transformations such as price standardization and brand identification.</p>
                                        </li>
                                        <li><strong>Upload to S3:</strong>
                                            <p>The <code>upload_s3</code> task uses the <code>upload_clean_file_to_s3</code> function to upload the cleaned data file to Amazon S3. This step ensures that the cleaned data is stored in a secure and scalable cloud storage service.</p>
                                        </li>
                                    </ul>
                                
                                    <h3>Task Dependencies</h3>
                                    <p>The extraction tasks (<code>morrissons_extract</code>, <code>asda_extract</code>, <code>aldi_extract</code>) run in parallel to gather data from each store simultaneously.</p>
                                    <p>Once all extraction tasks are completed, the <code>datafile_creation</code> task runs to create the unified data file.</p>
                                    <p>After the data file is created, the <code>datafile_cleanup</code> task runs to clean the data.</p>
                                    <p>Finally, the cleaned data file is uploaded to S3 by the <code>upload_s3</code> task.</p>
                                
                                    <p>By automating these steps, the Airflow pipeline ensures that retail data is collected, processed, and stored efficiently on a daily basis, enabling timely and accurate data analysis.</p>
                                
                                    <hr class="major" />
									<h2>Containerization with Docker</h2>

                                    <h3>Components of the Setup</h3>
                                    <ol>
                                        <li>
                                            <strong>Airflow</strong>: 
                                            <ul>
                                                <li><em>Role</em>: Manages the workflow of our data collection process, ensuring tasks are done in the right order and at the right time.</li>
                                            </ul>
                                        </li>
                                        <li>
                                            <strong>Selenium</strong>: 
                                            <ul>
                                                <li><em>Role</em>: Automatically visits and extracts data from retail websites.</li>
                                            </ul>
                                        </li>
                                        <li>
                                            <strong>Python & Pandas</strong>: 
                                            <ul>
                                                <li><em>Role</em>: Processes the collected data, cleaning and organizing it for analysis.</li>
                                            </ul>
                                        </li>
                                        <li>
                                            <strong>Docker</strong>: 
                                            <ul>
                                                <li><em>Role</em>: Ensures our setup runs smoothly on any system by bundling all the necessary components together.</li>
                                            </ul>
                                        </li>
                                    </ol>
                                    
                                    <h3>Containerized Services</h3>
                                    <p>We have several Docker containers, each responsible for a part of our system:</p>
                                    <ul>
                                        <li><strong>Airflow Container</strong>: Runs the Airflow service which schedules and coordinates tasks.</li>
                                        <li><strong>Browser Containers (Chrome & Firefox)</strong>: Run Selenium to interact with websites, allowing us to use different browsers for data collection.</li>
                                        <li><strong>Postgres Container</strong>: Stores our data in a structured way for easy retrieval and analysis.</li>
                                        <li><strong>Redis Container</strong>: Acts as a cache to speed up certain operations.</li>
                                    </ul>
                                    
                                    <h3>How It Works</h3>
                                    <ol>
                                        <li><strong>Task Scheduling</strong>: Airflow schedules tasks and ensures they run in the right order. For example, it will first trigger Selenium to collect data and then move to data processing.</li>
                                        <li><strong>Data Collection</strong>: Selenium, running in either Chrome or Firefox containers, visits retail websites and extracts data like prices, stock levels, etc.</li>
                                        <li><strong>Data Storage</strong>: The collected data is sent to the Postgres container, where it is stored securely.</li>
                                        <li><strong>Data Processing</strong>: Python scripts using Pandas run to clean and organize the data, making it ready for analysis.</li>
                                        <li><strong>Caching</strong>: Redis helps speed up the process by storing frequently accessed data temporarily.</li>
                                    </ol>
                                    
                                    <h3>Benefits</h3>
                                    <ul>
                                        <li><strong>Consistency</strong>: Ensures tasks run in the same way every time.</li>
                                        <li><strong>Scalability</strong>: Easy to add more tasks or scale up the system by adding more containers.</li>
                                        <li><strong>Portability</strong>: Docker containers can run on any system, making deployment easy.</li>
                                    </ul>

                                    <p>To further simplify management of docker, we use docker-compose, it greatly simplifies the docker lifecycle by providing helpful commands for handling containers. In this system, Docker Compose helps to streamline the deployment and orchestration of various services needed for our retail store data collection set up.</p>
                                    <p>
                                        This setup ensures that we have a robust, scalable, and portable system for collecting and processing retail store data efficiently.
                                    </p>

                                    <hr class="major" />
									<h2>Docker Registry with Amazon ECR</h2>

                                    <h3>1. Build the Images</h3>
                                    <p>
                                        First, use Docker Compose to build your images. This command reads the <code>docker-compose.yml</code> file and builds the images defined in it.
                                    </p>
                                    <pre><code>docker-compose build</code></pre>
                                
                                    <h3>2. Create an IAM Role with ECR Permissions</h3>
                                    <p>Ensure you have an IAM role with the necessary permissions to access ECR. Attach this policy to a new or existing IAM role. Make sure your AWS CLI or EC2 instance is using this IAM role.</p>
                                
                                    <h3>3. Log in to Your AWS Account</h3>
                                    <p>
                                        Ensure you have the AWS CLI installed and configured with your AWS credentials. Use the following command to log in to your AWS account:
                                    </p>
                                    <pre><code>aws configure</code></pre>
                                    <p>You will be prompted to enter your AWS Access Key, Secret Key, Region, and Output Format.</p>
                                
                                    <h3>4. Create ECR Repositories</h3>
                                    <p>
                                        Create repositories in ECR for each of the Docker images. You can do this through the AWS Management Console or using the AWS CLI:
                                    </p>
                                    <pre><code>aws ecr create-repository --repository-name airflow
aws ecr create-repository --repository-name chrome
aws ecr create-repository --repository-name firefox
aws ecr create-repository --repository-name postgres
aws ecr create-repository --repository-name redis</code></pre>
                                
                                    <h3>5. Authenticate Docker to Your ECR Registry</h3>
                                    <p>
                                        Use the AWS CLI to authenticate Docker to your ECR registry. Run the following command, which retrieves an authentication token and passes it to Docker:
                                    </p>
                                    <pre><code>aws ecr get-login-password --region &lt;your-region&gt; | 
docker login --username AWS --password-stdin &lt;aws_account_id&gt;
.dkr.ecr.&lt;your-region&gt;.amazonaws.com</code></pre>
                                    <p>Replace <code>&lt;your-region&gt;</code> with your AWS region and <code>&lt;aws_account_id&gt;</code> with your AWS account ID.</p>
                                
                                    <h3>6. Tag the Docker Images</h3>
                                    <p>
                                        Tag each Docker image with the repository URI. This step is necessary to push the images to the correct repositories in ECR. For example:
                                    </p>
                                    <pre><code>docker tag airflow:latest &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/airflow:latest
docker tag chrome:latest &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/chrome:latest
docker tag firefox:latest &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/firefox:latest
docker tag postgres:latest &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/postgres:latest
docker tag redis:latest &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/redis:latest</code></pre>
                                    <p>Replace <code>&lt;your-region&gt;</code> and <code>&lt;aws_account_id&gt;</code> accordingly.</p>
                                
                                    <h3>7. Push the Docker Images to ECR</h3>
                                    <p>
                                        Finally, push the tagged Docker images to the respective ECR repositories:
                                    </p>
                                    <pre><code>docker push &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/airflow:latest
docker push &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/chrome:latest
docker push &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/firefox:latest
docker push &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/postgres:latest
docker push &lt;aws_account_id&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com/redis:latest</code></pre>
                                
                                    <p>The steps ensure your Docker images are built, tagged, and pushed to your AWS ECR repositories, making them available for deployment.</p>


                                    <hr class="major" />
									<h2>Deployment on Digital Ocean</h2>
                                    <h3>1. Create an Account on DigitalOcean</h3>
                                    <p>If you don't already have an account, sign up for a new account on DigitalOcean.</p>
                                
                                    <h3>2. Spin Up a Droplet</h3>
                                    <p>Create a new droplet (virtual server) on DigitalOcean. Choose the specifications according to your needs (CPU, memory, storage).</p>
                                
                                    <h3>3. Set Up a Firewall</h3>
                                    <p>Before accessing your droplet, set up a firewall to control incoming traffic:</p>
                                    <ol>
                                        <li>Navigate to the "Networking" section in the DigitalOcean dashboard.</li>
                                        <li>Select "Firewalls" and create a new firewall.</li>
                                        <li>Add rules to allow necessary ports, such as:
                                            <ul>
                                                <li>SSH: TCP 22</li>
                                                <li>HTTP: TCP 80 (if needed)</li>
                                                <li>HTTPS: TCP 443 (if needed)</li>
                                                <li>Airflow: TCP 8080</li>
                                            </ul>
                                        </li>
                                        <li>Apply the firewall to your droplet.</li>
                                    </ol>
                                
                                    <h3>4. Pull the Docker Images from ECR</h3>
                                    <p>Once the droplet is ready, connect to it via SSH. Use the following steps to pull the Docker images from AWS ECR:</p>
                                    <ol>
                                        <li><strong>Install Docker</strong>:
                                            <pre><code>sudo apt update
sudo apt install docker.io -y
sudo systemctl start docker
sudo systemctl enable docker</code></pre>
                                        </li>
                                        <li><strong>Install Docker Compose</strong>:
                                            <pre><code>sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-
$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose</code></pre>
                                        </li>
                                        <li><strong>Authenticate Docker to ECR</strong>:
                                            <pre><code>aws ecr get-login-password --region &lt;your-region&gt; |
docker login --username AWS --password-stdin &lt;aws_account_id&gt;
.dkr.ecr.&lt;your-region&gt;.amazonaws.com</code></pre>
                                        </li>
                                    </ol>
                                
                                    <h3>5. Use the Server Docker Compose File</h3>
                                    <p>Upload the <code>server-docker-compose.yml</code> file to the server using <code>scp</code>:</p>
                                    <pre><code>scp path/to/server-docker-compose.yml user@your_droplet_ip:/path/on/server</code></pre>
                                
                                    <h3>6. Pull the Images</h3>
                                    <p>Navigate to the directory where you placed the <code>server-docker-compose.yml</code> file and pull the images:</p>
                                    <pre><code>cd /path/on/server
docker-compose -f server-docker-compose.yml pull</code></pre>
                                
                                    <h3>7. Copy the Airflow Environment File to the Server</h3>
                                    <p>Use <code>scp</code> or any other file transfer method to copy the <code>airflow.env</code> file to your droplet:</p>
                                    <pre><code>scp path/to/airflow.env user@your_droplet_ip:/path/on/server</code></pre>
                                
                                    <h3>8. Run Docker Compose to Start the Servers</h3>
                                    <p>Navigate to the directory where you placed the <code>server-docker-compose.yml</code> file and run Docker Compose:</p>
                                    <pre><code>cd /path/on/server
docker-compose -f server-docker-compose.yml up -d</code></pre>
                                
                                    <h3>9. Access the Airflow Environment</h3>
                                    <p>After running Docker Compose, your Airflow environment will be accessible via the droplet's IP address on the configured port which is 8080 for us.</p>
                                
                                    <h3>10. Copy the Commons Folder to the Server</h3>
                                    <p>We do not include the configs file to the docker image since they contain AWS keys among other credentials, we send the file to the server manually mounted as a volume.</p>
                                    <p>Copy the <code>commons</code> folder, which contains configurations not included in the images, to the server using <code>scp</code>:</p>
                                    <pre><code>scp -r path/to/commons user@your_droplet_ip:/path/on/server</code></pre>
                                    
                                    <hr class="major" />
									<h2>Running the Pipeline</h2>

                                    <h3>1. Access the Airflow Web Interface</h3>
                                    <p>After deploying your Airflow environment, access the Airflow web interface via the droplet's IP address and the configured port (default is usually port 8080). Open your web browser and go to:</p>
                                    <pre><code>http://your_droplet_ip:8080</code></pre>
                                
                                    <h3>2. Navigate to the DAGs Page</h3>
                                    <p>Once on the Airflow web interface, navigate to the "DAGs" page. This page lists all the available DAGs in your Airflow environment.</p>
                                
                                    <h3>3. Select the Retail DAG</h3>
                                    <p>Find the DAG named "retail" in the list and click on it to view more details about this DAG.</p>
                                    <span><img width="70%" src="images/retail-pipeline/main_dag.jpg" alt="" /></span>
                                    <p><p>
                                    <h3>4. Trigger the DAG</h3>
                                    <p>On the DAG details page, push the button on the top right corner labeled "Trigger DAG" to manually start the execution of the DAG.</p>
                                    <span><img width="70%" src="images/retail-pipeline/airflow_trigger.jpg" alt="" /></span>

                                    <hr class="major" />
									<h2>Conclusion</h2>
                                    
                                    <p>In conclusion, building a scalable retail data extraction pipeline involves a multifaceted approach leveraging various technologies and methodologies. By integrating tools like Selenium for web scraping, Python and Pandas for data processing, and Apache Airflow for orchestrating tasks, the project ensures efficient data extraction and transformation. Docker and AWS services provide the necessary scalability and reliability, while strategic project structuring enhances maintainability and collaboration. Overcoming challenges such as IP blocking and data inconsistencies, the pipeline successfully consolidates and cleans retail data, enabling insightful analysis and decision-making. This comprehensive solution not only tracks grocery prices but also offers a robust framework adaptable to other data extraction needs, reinforcing the importance of real-time data in today's dynamic retail environment.</p>
                                    
								</section>

						</div>
					</div>
				<!-- Sidebar -->
                <div id="sidebar">
                    <div class="inner">

                        <!-- Search -->
                            <section id="search" class="alt">
                                <form method="post" action="#">
                                    <input type="text" name="query" id="query" placeholder="Search" />
                                </form>
                            </section>

                        <!-- Menu -->
                            <nav id="menu">
                                <header class="major">
                                    <h2>Menu</h2>
                                </header>
                                <ul>
                                    <li><a href="index.html">Homepage</a></li>
                                    <li><a href="resume.html">Resume</a></li>
                                    <li>
                                        <span class="opener">Projects</span>
                                        <ul>
                                            <li><a href="salary_cleansing.html">Salary Data Cleansing</a></li>
                                            <li><a href="project_2.html">Food Delivery Analysis</a></li>
                                            <li><a href="retail_pipeline.html">UK Retail Data Pipeline</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <span class="opener">Blogs</span>
                                        <ul>
                                            <li><a href="blog_sql_question.html">Postgresql Generate Series</a></li>
                                            <li><a href="blog_scraping_simple_food_orders.html">Simple Scraping and Transformation</a></li>
                                        </ul>
                                    </li>
                                </ul>
                            </nav>

                        <!-- Section -->
                            <section>
                                <header class="major">
                                    <h2>Get in touch</h2>
                                </header>
                                <p>Do get in touch if you are looking for a professional working in the field of data.</p>
                                <ul class="contact">
                                    <li class="icon solid fa-envelope"><a href="#">milangarg6991@gmail.com</a></li>
                                    <li class="icon solid fa-phone">(+44) 7741-851570</li>
                                    <li class="icon solid fa-home">St Marks Street<br />
                                    Leeds, UK</li>
                                </ul>
                            </section>

                        <!-- Footer -->
                        <footer id="footer">
                            <p class="copyright">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
                        </footer>

                    </div>
                </div>


			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>